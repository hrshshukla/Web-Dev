// (try...catch) works synchronously 
// So, if a function(X) inside (try...catch) takes timeValue then, function(X) will be executed at last
// At this point (try...catch) & function(X) both get seperated in execution heirarchy 
// Execution heirarchy :  [1] try&catch -----> [2] function(X)
// means (try...catch) will get executed first without function(X) 
// Now, if any error is generated by function(X) then (try...catch) are not responsible to handle that error as they are already executed 

// When ERROR got Catched 
function normalFunction() {
    try {
        return UndefinedVar // ❌ This variable is not declared, so it will cause an error
    }
    catch (errorMsg){
        console.log("Catch() is triggered : found ERROR") // -----> Output : Catch() is triggered : found ERROR
    } 
}
normalFunction()


// When ERROR didn't get catched 
function functionWithTimeValue() {
    try {
        setTimeout(() => {
            return UndefinedVar // ❌ This variable is not declared, so it will cause an error
        }, 2000);
    }
    catch (errorMsg){
        console.log("Catch() is triggered : found ERROR") // -----> Catch() will not trigger because it executed already before [setTimeout] 
    } 
}

functionWithTimeValue() // ---> will give ❌ ERROR

